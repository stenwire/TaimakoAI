name: Deploy to VPS

on:
  push:
    branches:
      - prod
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  PROJECT_PREFIX: "taimako"

  # Static environment variables
  BACKEND_ENV: >-
    -e ENVIRONMENT="production"
    -e DATABASE_URL="postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@${{ secrets.POSTGRES_HOST }}:5432/${{ secrets.POSTGRES_DB }}"
    -e GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}"
    -e GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}"
    -e GOOGLE_REDIRECT_URI="${{ secrets.GOOGLE_REDIRECT_URI }}"
    -e FRONTEND_REDIRECT_URI="${{ secrets.FRONTEND_REDIRECT_URI }}"

  FRONTEND_ENV: >-
    -e NODE_ENV="production"
    -e NEXT_PUBLIC_ENVIRONMENT="production"
    -e NEXT_PUBLIC_API_URL="${{ secrets.NEXT_PUBLIC_API_URL }}"
    -e NEXT_PUBLIC_BACKEND_URL_PROD="${{ secrets.NEXT_PUBLIC_BACKEND_URL_PROD }}"
    -e NEXT_PUBLIC_FRONTEND_URL_PROD="${{ secrets.NEXT_PUBLIC_FRONTEND_URL_PROD }}"

jobs:
  build-and-push-backend:
    runs-on: ld-vps-runner
    permissions:
      contents: read
      packages: write

    steps:
      - name: Set lowercase image names
        id: image-names
        run: |
          echo "backend_image=$(echo '${{ github.repository }}-backend' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT
          echo "frontend_image=$(echo '${{ github.repository }}-frontend' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        run: echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Build and push Backend image
        run: |
          cd backend
          docker build \
            -t ${{ env.REGISTRY }}/${{ steps.image-names.outputs.backend_image }}:latest \
            -t ${{ env.REGISTRY }}/${{ steps.image-names.outputs.backend_image }}:${{ github.sha }} \
            -f Dockerfile.prod .
          docker push ${{ env.REGISTRY }}/${{ steps.image-names.outputs.backend_image }}:latest
          docker push ${{ env.REGISTRY }}/${{ steps.image-names.outputs.backend_image }}:${{ github.sha }}
          docker rmi ${{ env.REGISTRY }}/${{ steps.image-names.outputs.backend_image }}:${{ github.sha }} || true

  build-and-push-frontend:
    needs: [build-and-push-backend]
    runs-on: ld-vps-runner
    permissions:
      contents: read
      packages: write

    steps:
      - name: Set lowercase image names
        id: image-names
        run: |
          echo "backend_image=$(echo '${{ github.repository }}-backend' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT
          echo "frontend_image=$(echo '${{ github.repository }}-frontend' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        run: echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Build and push Frontend image
        run: |
          cd frontend
          docker build \
            -t ${{ env.REGISTRY }}/${{ steps.image-names.outputs.frontend_image }}:latest \
            -t ${{ env.REGISTRY }}/${{ steps.image-names.outputs.frontend_image }}:${{ github.sha }} \
            -f Dockerfile.prod \
            --build-arg NEXT_PUBLIC_ENVIRONMENT="production" \
            --build-arg NEXT_PUBLIC_API_URL="${{ secrets.NEXT_PUBLIC_API_URL }}" \
            --build-arg NEXT_PUBLIC_BACKEND_URL_PROD="${{ secrets.NEXT_PUBLIC_BACKEND_URL_PROD }}" \
            --build-arg NEXT_PUBLIC_FRONTEND_URL_PROD="${{ secrets.NEXT_PUBLIC_FRONTEND_URL_PROD }}" \
            .
          docker push ${{ env.REGISTRY }}/${{ steps.image-names.outputs.frontend_image }}:latest
          docker push ${{ env.REGISTRY }}/${{ steps.image-names.outputs.frontend_image }}:${{ github.sha }}
          docker rmi ${{ env.REGISTRY }}/${{ steps.image-names.outputs.frontend_image }}:${{ github.sha }} || true

  deploy:
    needs: [build-and-push-backend, build-and-push-frontend]
    runs-on: ld-vps-runner

    steps:
      - name: Set dynamic variables
        id: vars
        run: |
          PREFIX="${{ env.PROJECT_PREFIX }}"
          echo "postgres_container=${PREFIX}_postgres" >> $GITHUB_OUTPUT
          echo "backend_container=${PREFIX}_backend" >> $GITHUB_OUTPUT
          echo "frontend_container=${PREFIX}_frontend" >> $GITHUB_OUTPUT
          echo "docker_network=${PREFIX}_network" >> $GITHUB_OUTPUT
          echo "data_dir=~/${PREFIX}" >> $GITHUB_OUTPUT
          echo "postgres_data_dir=~/${PREFIX}/postgres_data" >> $GITHUB_OUTPUT
          echo "backups_dir=~/${PREFIX}/backups" >> $GITHUB_OUTPUT

      - name: Set lowercase image names
        id: image-names
        run: |
          echo "backend_image=$(echo '${{ github.repository }}-backend' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT
          echo "frontend_image=$(echo '${{ github.repository }}-frontend' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        run: echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Pull latest images
        run: |
          docker pull ${{ env.REGISTRY }}/${{ steps.image-names.outputs.backend_image }}:latest
          docker pull ${{ env.REGISTRY }}/${{ steps.image-names.outputs.frontend_image }}:latest

      - name: Create Docker network
        run: docker network create ${{ steps.vars.outputs.docker_network }} || true

      - name: Deploy PostgreSQL container
        run: |
          mkdir -p ${{ steps.vars.outputs.postgres_data_dir }}
          mkdir -p ${{ steps.vars.outputs.backups_dir }}

          if docker ps -a --format '{{.Names}}' | grep -q "^${{ steps.vars.outputs.postgres_container }}$"; then
            echo "PostgreSQL container exists."
            if ! docker ps --format '{{.Names}}' | grep -q "^${{ steps.vars.outputs.postgres_container }}$"; then
              echo "Starting stopped PostgreSQL container..."
              docker start ${{ steps.vars.outputs.postgres_container }}
            fi
          else
            echo "Creating new PostgreSQL container..."
            docker run -d \
              --name ${{ steps.vars.outputs.postgres_container }} \
              --network ${{ steps.vars.outputs.docker_network }} \
              --restart unless-stopped \
              -v ${{ steps.vars.outputs.postgres_data_dir }}:/var/lib/postgresql/data \
              -e POSTGRES_USER="${{ secrets.POSTGRES_USER }}" \
              -e POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
              -e POSTGRES_DB="${{ secrets.POSTGRES_DB }}" \
              postgres:16-alpine
          fi

          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if docker exec ${{ steps.vars.outputs.postgres_container }} pg_isready -U "${{ secrets.POSTGRES_USER }}" > /dev/null 2>&1; then
              echo "PostgreSQL is ready!"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done

      - name: Deploy Backend container
        run: |
          docker stop ${{ steps.vars.outputs.backend_container }} || true
          docker rm ${{ steps.vars.outputs.backend_container }} || true

          # Run migrations
          docker run --rm \
            --network ${{ steps.vars.outputs.docker_network }} \
            ${{ env.BACKEND_ENV }} \
            ${{ env.REGISTRY }}/${{ steps.image-names.outputs.backend_image }}:latest \
            alembic upgrade head

          # Run backend
          docker run -d \
            --name ${{ steps.vars.outputs.backend_container }} \
            --network ${{ steps.vars.outputs.docker_network }} \
            --restart unless-stopped \
            -p 127.0.0.1:8000:8000 \
            ${{ env.BACKEND_ENV }} \
            ${{ env.REGISTRY }}/${{ steps.image-names.outputs.backend_image }}:latest

      - name: Deploy Frontend container
        run: |
          docker stop ${{ steps.vars.outputs.frontend_container }} || true
          docker rm ${{ steps.vars.outputs.frontend_container }} || true

          docker run -d \
            --name ${{ steps.vars.outputs.frontend_container }} \
            --network ${{ steps.vars.outputs.docker_network }} \
            --restart unless-stopped \
            -p 127.0.0.1:3000:3000 \
            ${{ env.FRONTEND_ENV }} \
            ${{ env.REGISTRY }}/${{ steps.image-names.outputs.frontend_image }}:latest

      - name: Wait for containers to be ready
        run: sleep 10

      - name: Check container health
        run: |
          docker ps -a --filter "name=${{ env.PROJECT_PREFIX }}"

          for container in "${{ steps.vars.outputs.postgres_container }}" "${{ steps.vars.outputs.backend_container }}" "${{ steps.vars.outputs.frontend_container }}"; do
            if ! docker ps --format '{{.Names}}' | grep -q "^$container$"; then
              echo "$container container failed to start!"
              docker logs $container
              exit 1
            fi
          done

          echo "All containers are running successfully!"

      - name: Backup database
        run: |
          docker exec ${{ steps.vars.outputs.postgres_container }} pg_dump -U "${{ secrets.POSTGRES_USER }}" "${{ secrets.POSTGRES_DB }}" > ${{ steps.vars.outputs.backups_dir }}/backup_$(date +%Y%m%d_%H%M%S).sql
          ls -t ${{ steps.vars.outputs.backups_dir }}/*.sql | tail -n +8 | xargs -r rm

      - name: Final cleanup
        if: always()
        run: |
          docker system prune -af --filter "until=24h"
          echo "=== Final disk space ==="
          df -h